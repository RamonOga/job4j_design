1. Что такое SOLID?
SOLID принципы советуют, как проектировать модули, т.е. кирпичики, из которых строится приложение. Цель принципов — проектировать модули, которые:

2. Для чего используются JavaDoc?
Javadoc — генератор документации в HTML-формате из комментариев исходного кода на Java.
 Javadoc также предоставляет API для создания доклетов и тэглетов, которые позволяют программисту анализировать структуру Java-приложения.
 В каждом случае комментарий должен находиться перед документируемым элементом. @author, @version, @since

Многие IDE также используют Javadocs для генерации контекстных описаний API.

к оглавлению

3. Как писать JavaDoc?
Утилита javadoc позволяет вставлять HTML тэги и использовать специальные ярлыки (дескрипторы) документирования. НТМL тэги заголовков не используют, чтобы не нарушать стиль файла, сформированного утилитой. Дескрипторы javadoc, начинающиеся со знака @, называются автономными и должны помещаться с начала строки комментария (лидирующий символ * игнорируется). Дескрипторы, начинающиеся с фигурной скобки, например {@code}, называются встроенными и могут применяться внутри описания.

Комментарии документации применяют для документирования классов, интерфейсов, полей (переменных), конструкторов и методов. В каждом случае комментарий должен находиться перед документируемым элементом.

Документирование класса, метода или переменной начинается с комбинации символов /** , после которого следует тело комментариев; заканчивается комбинацией символов */. В тело комментариев можно вставлять различные дескрипторы. Каждый дескриптор, начинающийся с символа '@' должен стоять первым в строке. Несколько дескрипторов одного и того же типа необходимо группировать вместе. Встроенные дескрипторы (начинаются с фигурной скобки) можно помещать внутри любого описания.

/** 
 * Класс продукции со свойствами <b>maker</b> и <b>price</b>.
 * @autor Киса Воробьянинов
 * @version 2.1
*/
class Product {
    /**
     * Поле производитель 
     */
    private String maker;
     
    /** 
     * Поле цена 
     */ 
    public double price;
    
    /** 
     * Конструктор - создание нового объекта
     * @see Product#Product(String, double)
     */
    Product() {
        setMaker("");
        price=0;
    }
    
    /** 
     * Конструктор - создание нового объекта с определенными значениями
     * @param maker - производитель
     * @param price - цена
     * @see Product#Product()
     */
    Product (String maker, double price) {
        this.setMaker(maker);
        this.price=price;
    }
    
    /**
     * Функция получения значения поля {@link Product#maker}
     * @return возвращает название производителя
     */
    public String getMaker() {
        return maker;
    }
    
    /**
     * Процедура определения производителя {@link Product#maker}
     * @param maker - производитель
     */
    public void setMaker(String maker) {
        this.maker = maker;
    }
}
к оглавлению

4. Что такое Java code convention?
Документ Oracle по правилам оформления кода. Соглашения по офрмлению кода важны для программистов по ряду причин:

80% от стоимости программного обеспечения приходится на его обслуживание.
Вряд ли какое-либо программное обеспечение все время поддерживается первоначальным разработчиком.
Соглашения по оформлению кода делают исходный код программ более удобочитаемым, позволяя инженерам быстрее и тщательнее понимать новый код.
Если вы предоствляете исходный код как продукт, вы должны убедится, что он хорошо оформлен и упакован как любой другой продукт который вы создаете
Code conventions

к оглавлению

5. Расскажите про принципы составления Java класса?
SRP (single responsibility) - принцип единственной ответственности - никогда не должно быть больше одной причины изменить класс. Действительное следствие закона Конвея: лучшей является такая структура программной системы, которая формируется в основном под влиянием социальной структуры организации, использующей эту систему, поэтому каждый программный модуль имеет одну и только одну причину для изменения. Закон Конвея — «Организации, проектирующие системы, ограничены дизайном, который копирует структуру коммуникации в этой организации»

OCP (open-closed) - принцип открытости/закрытости - программные сущности (классы, модули, функции и т.п.) должны быть открыты для расширения, но закрыты для изменения. Простая для изменения система должна предусматривать простую возможность изменения ее поведения добавлением нового, но не изменением существующего кода.

LSP (Liskov substitution) - принцип подстановки Барбары Лисков - объекты в программе можно заменить их наследниками без изменения свойств программы. Это вариация принципа открытости/закрытости. Для создания программных систем из взаимозаменяемых частей эти части должны соответствовать контракту, который позволяет заменять эти части друг другом.

ISP (interface segregation) - принцип разделения интерфейса - клиенты не должны реализовывать методы, которые они не будут использовать. Этот принцип призывает разработчиков программного обеспечения избегать зависимости от всего, что не используется.

DIP (dependency inversion) - принцип инверсии зависимостей - зависимости внутри системы строятся на основе абстракций, а не конкретных реализаций. Код, реализующий высокоуровневую политику, не должен зависеть от кода, реализующего низкоуровневые детали. Напротив, детали должны зависеть от политики.

img

к оглавлению

6. Что такое SRP?
A module should be responsible to one, and only one, actor (Модуль должен отвечать за одного и только за одного актора).

Старая формулировка: A module should have one, and only one, reason to change (Модуль должен иметь одну и только одну причину для изменения).

Часто ее трактовали следующим образом: Модуль должен иметь только одну обязанность. И это главное заблуждение при знакомстве с принципами. Все несколько хитрее.

На каждом проекте люди играют разные роли (actor): Аналитик, Проектировщик интерфейсов, Администратор баз данных. Естественно, один человек может играть сразу несколько ролей. В этом принципе речь идет о том, что изменения в модуле может запрашивать одна и только одна роль. Например, есть модуль, реализующий некую бизнес-логику, запросить изменения в этом модуле может только Аналитик, но никак не DBA или UX.

к оглавлению

7. Расскажите о нарушениях принципа SRP?
Пример 1. Чистая архитекура Р.Мартин 2017

Например, класс Employee из приложения платежной ведомости имеет три метода: calculatePay(), reportHours() и save()

img

Этот класс нарушает принцип единственной ответственности, потому что три его метода отвечают за три разные роли.

Реализация метода calculatePay() определяется бухгалтерией.
Реализация метода reportHours() определяется и используется отделом по работе с персоналом.
Реализация метода save() определяется администраторами баз данных.
Поместив исходный код этих трех методов в общий класс Employee, разработчики объединили перечисленные роли. В результате такого объединения действия сотрудников бухгалтерии могут затронуть что-то, что требуется сотрудникам отдела по работе с персоналом. Допустим, функции calculatePay() и reportHours() используют общий алгоритм расчета не сверхурочных часов. Разработчики, старающиеся не дублировать код, поместили реализацию этого алгоритма в функцию с именем regularHours()

img

Допустим, сотрудники бухгалтерии решили изменить алгоритм расчета не сверхурочных часов. Сотрудники отдела кадров были бы против такого изменения, т.к. вычисленное время они используют для других целей.

Разработчик, внесящий это изменение, заметил, что функция regularHours() вызывается методом calculatePay(), но не заметил, что она также вызывается методом reportHours(). Он внес требуемые изменения и протестировал результат. Сотрудники бухгалтерии проверили и подтвердили, что обновленная функция работает верно, после чего измененная версия системы была развернута.

Сотрудники отдела кадров не знали этого и продолжали использовать отчеты, генерируемые функцией reportHours(), но теперь содержащие неправильные цифры. В какой-то момент проблема вскрылась, и выяснилось, что ошибочные данные обошлись бюджету фирмы в несколько миллионов.

Эти проблемы возникают из-за того, что мы вводим в работу код, от которого зависят разные роли. Принцип единственной ответственности требует разделять код, от которого зависят разные роли.

Существует несколько решений этой проблемы. Но каждое связано с перемещением функций в разные классы.

Наиболее очевидное решение - отделить данные от функций. Три класса используют общие данные EmployeeData — простую структуру без методов.

img

Каждый класс включает только исходный код для конкретной функции. Эти три класса никак не зависят друг от друга. То есть любое непреднамеренное дублирование исключено.

Недостаток такого решения — разработчик теперь должен создавать экземпляры трех классов и следить за ними.

Эта проблема часто решается применением шаблона проектирования «Фасад» (Facade), как показано на рис.

img

Класс EmployeeFacade компактный и отвечает за создание экземпляров трех классов и делегирование вызовов методов.

Пример 2.

Представьте себе модуль, который обрабатывает заказы. Если заказ верно сформирован, он сохраняет его в базу данных и высылает письмо для подтверждения заказа:

public class OrderProcessor {

    public void process(Order order){
        if (order.isValid() && save(order)) {
            sendConfirmationEmail(order);
        }
    }

    private boolean save(Order order) {
        MySqlConnection connection = new MySqlConnection("database.url");
        // сохраняем заказ в базу данных

        return true;
    }

    private void sendConfirmationEmail(Order order) {
        String name = order.getCustomerName();
        String email = order.getCustomerEmail();

        // Шлем письмо клиенту
    }
}
Такой модуль может измениться по трем причинам:

может стать другой логика обработки заказа,
может измениться способ его сохранения (тип базы данных),
может измениться способ отправки письма подтверждения (вместо email нужно отправлять SMS).
Принцип SRP подразумевает, что три аспекта этой проблемы на самом деле — три разные обязанности. А значит, они должны находиться в разных классах или модулях. Объединение нескольких сущностей, которые могут меняться в разное время и по разным причинам, плохое проектное решение.

Правильнее разделить модуль на три отдельных, каждый из которых будет выполнять одну единственную функцию:

public class MySQLOrderRepository {
    public boolean save(Order order) {
        MySqlConnection connection = new MySqlConnection("database.url");
        // сохраняем заказ в базу данных

        return true;
    }
}

public class ConfirmationEmailSender {
    public void sendConfirmationEmail(Order order) {
        String name = order.getCustomerName();
        String email = order.getCustomerEmail();

        // Шлем письмо клиенту
    }
}

public class OrderProcessor {
    public void process(Order order){

        MySQLOrderRepository repository = new MySQLOrderRepository();
        ConfirmationEmailSender mailSender = new ConfirmationEmailSender();

        if (order.isValid() && repository.save(order)) {
            mailSender.sendConfirmationEmail(order);
        }
    }

}
Еще примеры

к оглавлению

8. Последствия нарушения SRP?
Что является причиной изменения логики работы класса? Изменение отношений между классами, введение новых требований или отмена старых.

Если изменения в модуле могут запрашивать несколько ролей, то и меняться он будет часто. А это ведет к хрупкости дизайна и ошибкам в неожиданных местах при изменениях кода.

к оглавлению

9. Что такое OCP?
A software artifact should be open for extension but closed for modification (Программный артефакт должен быть открыт для расширения, но закрыт для модификации.).

Старая формулировка: You should be able to extend a classes behavior, without modifying it (Вы должны иметь возможность расширять поведение классов, не изменяя его).

Программные сущности (классы, модули, функции и т. п.) должны быть открыты для расширения, но закрыты для изменения. Это означает, что такие сущности могут позволять менять свое поведение без изменения их исходного кода.

Принцип открытости/закрытости — одна из движущих сил в архитектуре систем. Его цель — сделать систему легко расширяемой и обезопасить ее от влияния изменений. Эта цель достигается делением системы на компоненты и упорядочением их зависимостей в иерархию, защищающую компоненты уровнем выше от изменений в компонентах уровнем ниже.

Этот принцип тесно связан с LSP и DIP.

к оглавлению

10. Расскажите о нарушениях принципа OCP?
Пример 1.

Предположим, способ отправки письма подтверждения был реализован следующим образом:

public class MessageSender {
    //Шлем уведомление клиенту
    public void send(String msg, MessageType type) {
        if (type == MessageType.SMS) {
            sendSMS(msg);
        } else if (type == MessageType.EMAIL) {
                           sendEMAIL(msg);
                       }
    }
}
здесь нарушен OCP принцип, т.к. при изменении способов отправки уведомлений придется менять существующий код. Воспользуемся паттерном "Стратегия" для решения проблемы:

//Создаем интерфейс
interface SendingStrategy {
    void send(String msg);
}

//Создаем контекстный класс
public class MessageSender {
    private SendingStrategy strategy;
    
    public MessageSender(SendingStrategy strategy) {
        this.strategy = strategy;
    }
   
    public void send(String msg) {
             this.strategy.send(msg);  
    }
}

//Реализуем конкретные стратегии отправки
public class EmailSendingStrategy implements SendingStrategy {
    
    @Override
    public void send(String msg) {
        System.out.println("Sending Email: " + msg); 
    }
}

public class SMSSendingStrategy implements SendingStrategy {
    
    @Override
    public void send(String msg) {
        System.out.println("Sending SMS: " + msg); 
    }
}
теперь, чтобы добавить новый способ отправки уведомлений, нужно просто реализовать еще одну стратегию, не меняя существующий код.

Пример 2.

Продолжая пример с заказом, предположим, что нам нужно выполнять какие-то действия перед обработкой заказа и после отправки письма с подтверждением. Вместо того, чтобы менять сам класс OrderProcessor, мы расширим его и добьемся решения поставленной задачи, не нарушая принцип OCP:

public class OrderProcessorWithPreAndPostProcessing extends OrderProcessor {

    @Override
    public void process(Order order) {
        beforeProcessing();
        super.process(order);
        afterProcessing();
    }

    private void beforeProcessing() {
        // Осуществим некоторые действия перед обработкой заказа
    }

    private void afterProcessing() {
        // Осуществим некоторые действия после обработки заказа
    }
}
Еще примеры

к оглавлению

11. Последствия нарушения OCP?
При изменении требований придется каждый раз изменять существующий код, что влечет за собой также изменение тестов.

к оглавлению

12. Что такое LSP?
Определение подтипов, данное Барбарой Лисков:

Здесь требуется что-то вроде следующего свойства подстановки: если для каждого объекта o1 типа S существует такой объект o2 типа T, что для всех программ P, определенных в терминах T, поведение P не изменяется при подстановке o1 вместо o2, то S является подтипом T.

Эта идея лежит в основе LSP, который звучит так: Функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа, не зная об этом. Подклассы не могут замещать поведения базовых классов. Подтипы должны дополнять базовые типы.

Руководство по использованию наследования:

Пусть класс с именем License, имеет метод с именем calcFee(), который вызывается приложением Billing. Существует два «подтипа» класса License: PersonalLicense и BusinessLicense. Они реализуют разные алгоритмы расчета лицензионных отчислений.

img

Этот дизайн соответствует принципу подстановки Барбары Лисков, потому что поведение приложения Billing не зависит от использования того или иного подтипа. Оба подтипа могут служить заменой для типа License.

к оглавлению

13. Расскажите о нарушениях принципа LSP?
LSP тесно связан с принципом единственной ответственности и принципом разделения интерфейса.

Если класс реализует больше функциональности, чем подкласс, то последний может не поддерживать некоторые функции и тем самым нарушает данный принцип.

Классические примеры нарушения LSP - это проблемы квадрат/прямоугольник и круг/эллипс.

Пример 1.

Проблема квадрат/прямоугольник

img

class Rectangle {
	
	public int getWidth() {
		return width;
	}
	
	public int getHeight() {
		return height;
	}
	
	public void setWidth(int width) {
		this.width = width;
	}
	
	public void setHeight(int height) {
		this.height = height;
	}
	
	public int getArea() {
	    return this.width * this.height;
	}
}

class Square extends Rectangle {
	
	@Override
	public void setWidth(int width) {
		this.width = width;
		this.height = width;
	}
	
	@Override
	public void setHeight(int height) {
		this.height = height;
		this.width = height;
	}
}

public class Main {
    static void resize(Rectangle r, int new_width, int new_height) {
        r.setWidth(new_width);
        r.setHeight(new_height); 
    }

	public static void main(String[] args) {
		Rectangle r = new Rectangle();
		Square s = new Square();
		resize(r,2,3);
		resize(s,2,3);
		System.out.println(r.getArea()); //2*3=6
		System.out.println(s.getArea()); //ошибка
	}
}
Функция resize() провоцирует неявную ошибку при работе с экземпляром класса Square, потому что позволяет устанавливать отличные друг от друга значения ширины и высоты. Согласно принципу LSP, функции, использующие ссылки на базовые классы, должны иметь возможность использовать объекты производных классов, не зная об этом. Поэтому для корректной работы функция resize() должна проверять, является ли передаваемый объект экземпляром класса Square, и в этом случае не позволять установить разные значения ширины и высоты. Отсюда идёт нарушение принципа.

Пример 2.

Предположим есть класс, который отвечает за валидацию заказа и проверяет, все ли из товаров заказа находятся на складе. У данного класса есть метод isValid который возвращает true или false: public class OrderStockValidator {

public class OrderStockValidator {
    
    public boolean isValid(Order order) {
        for (Item item : order.getItems()) {
            if (! item.isInStock()) {
                return false;
            }
        }
        return true;
    }
}
Также предположим, что некоторые заказы нужно валидировать иначе: проверять, все ли товары заказа находятся на складе и все ли товары упакованы. Для этого мы расширили класс OrderStockValidator классом OrderStockAndPackValidator:

public class OrderStockAndPackValidator extends OrderStockValidator {

    @Override
    public boolean isValid(Order order) {
        for (Item item : order.getItems()) {
            if (!item.isInStock() || !item.isPacked()){
                throw new IllegalStateException(
                     String.format("Order %d is not valid!", order.getId())
                );
            }
        }
        return true;
    }
}
Однако в данном классе мы нарушили принцип LSP, так как вместо того, чтобы вернуть false, если заказ не прошел валидацию, наш метод бросает исключение IllegalStateException. Клиенты данного кода не рассчитывают на такое: они ожидают возвращения true или false. Это может привести к ошибкам в работе программы.

Еще примеры

к оглавлению

14. Последствия нарушения LSP?
Неожиданное поведение классов. Ошибки в программе при замене на подклассы.

к оглавлению

15. Что такое ISP?
Make fine grained interfaces, that are client specific. Клиенты не должны реализовывать методы, которые они не будут использовать.

Много специализированных интерфейсов лучше, чем один универсальный. Иными словами большие, объемные интерфейсы нужно разбивать на мелкие таким образом, чтобы клиенты маленьких интерфейсов знали только о тех методах, которые необходимы им в работе. Также при изменении метода интерфейса не должны меняться клиенты, которые этот метод не используют.

к оглавлению

16. Расскажите о нарушениях принципа ISP?
Пример 1. ISP и язык

Пусть имеется несколько классов, пользующихся операциями в классе OPS. Допустим, что User1 использует только операцию op1, User2 — только op2 и User3 — только op3.

img

Теперь представьте, что OPS — это класс, написанный на таком языке, как Java. Очевидно, что исходный код User1 непреднамеренно будет зависеть от op2 и op3, даже при том, что он не пользуется ими. Эта зависимость означает, что изменения в исходном коде метода op2 в классе OPS потребуют повторной компиляции и развертывания класса User1, несмотря на то, что для него ничего не изменилось. Эту проблему можно решить разделением операций по интерфейсам:

img

Если снова представить, что этот интерфейс реализован на языке со строгим контролем типов, таком как Java, исходный код User1 будет зависеть от U1Ops и op1, но не от OPS. То есть изменения в OPS, которые не касаются User1, не потребуют повторной компиляции и развертывания User1.

Очевидно, что описание выше в значительной степени зависит от типа языка. Языки со статическими типами, такие как Java, вынуждают программистов создавать объявления, которые должны импортироваться или подключаться к исходному коду пользователя как-то иначе. Именно эти инструкции подключения в исходном коде пользователя создают зависимости и вынуждают выполнять повторную компиляцию и развертывание.

Пример 2. ISP и архитектура

В общем случае опасно создавать зависимости от модулей, содержащих больше, чем требуется. Это справедливо не только в отношении зависимостей в исходном коде, которые могут вынуждать выполнять без необходимости повторную компиляцию и развертывание, но также на более высоком уровне — на уровне архитектуры.

Рассмотрим, например, действия архитектора, работающего над системой S. Он пожелал включить в систему некоторый фреймворк F. Теперь представьте, что авторы F связали его с поддержкой конкретной базы данных D. То есть S зависит от F, который зависит от D

Например, архитектор, работает над системой S. Он пожелал включить в систему некоторый фреймворк F. Теперь представьте, что авторы F связали его с поддержкой конкретной базы данных D. То есть S зависит от F, который зависит от D

img

Представьте, что D включает функции, которые не используются фреймворком F и, соответственно, не используются системой S. Изменения в этих функциях внутри D могут вынудить повторно развернуть F и, соответственно, повторно развернуть S. Более того, ошибка в одной из таких функций внутри D может спровоцировать появление ошибок в F и S.

Т.е. зависимости, несущие лишний груз ненужных и неиспользуемых особенностей, могут стать причиной неожиданных проблем.

Еще примеры

к оглавлению

17. Последствия нарушения ISP?
Дублирование кода - мы вынуждены будем переопределять неиспользуемые методы в классах, реализующих "большой" интерфейс.

Кроме того, с точки зрения архитектуры проекта, зависимости, несущие лишний груз ненужных и неиспользуемых особенностей, могут стать причиной неожиданных проблем.

к оглавлению

18. Что такое DIP?
Depend on abstractions, not on concretions. Зависимости внутри системы строятся на основе абстракций, а не конкретных реализаций.

Наиболее гибкими получаются системы, в которых зависимости в исходном коде направлены на абстракции, а не на конкретные реализации.

Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.
Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.
Что такое модули верхних уровней? Как определить этот уровень? Как оказалось, все очень просто. Чем ближе модуль к вводу/выводу, тем ниже уровень модуля. Т.е. модули, работающие с BD, интерфейсом пользователя, низкого уровня. А модули, реализующие бизнес-логику — высокого уровня.

Что такое зависимость модулей? Это ссылка на модуль в исходном коде, т.е. import, require и т.п. С помощью динамического полиморфизма в runtime можно обратить эту зависимость.

Есть модуль Logic, реализующий логику, который должен отсылать уведомления. В этом же пакете объявляется интерфейс ISender, который используется Logic. Уровнем ниже, в другом пакете объявляется ConcreteSender, реализующий ISender. Получается, что в момент компиляции Logic не зависит от ConcreteSender. В runtime, например, через конструктор в Logic устанавливается экземпляр ConcreteSender.

Отдельно стоит отметить частый вопрос: "Зачем плодить абстракции, если мы не собираемся заменять базу данных?".

Логика тут следующая. На старте проекта, мы знаем, что будем использовать реляционную базу данных, и это точно будет Postgresql, а для поиска — ElasticSearch. Мы даже не планируем их менять в будущем. Но мы хотим отложить принятие решений о том, какая будет схема таблиц, какие будут индексы, и т.п. до момента, пока это не станет проблемой. И на этот момент мы будем обладать достаточной информацией, чтобы принять правильное решение. Также мы можем раньше отладить логику нашего приложения, реализовать интерфейс, собрать обратную связь от заказчика, и минимизировать последующие изменения, ведь многое реализовано только в виде заглушек.

к оглавлению

19. Расскажите о нарушениях принципа DIP?
Программное обеспечение нужно разрабатывать так, чтобы различные модули были автономными и соединялись друг с другом с помощью абстракции.

Пример.

Пусть есть модуль, который обрабатывает заказы. Если заказ верно сформирован, он сохраняет его в базу данных и высылает письмо для подтверждения заказа:

public class OrderProcessor {
    
    public void process(Order order) {

        MySQLOrderRepository repository = new MySQLOrderRepository();
        ConfirmationEmailSender mailSender = new ConfirmationEmailSender();

        if (order.isValid() && repository.save(order)) {
            mailSender.sendConfirmationEmail(order);
        }
    }
}
В данном примере наш OrderProcessor зависит от двух конкретных классов MySQLOrderRepository и ConfirmationEmailSender. Эти классы далеки от того, чтобы называться абстракциями. И с точки зрения принципа DIP было бы правильнее для начала создать некоторые абстракции, которые позволят нам оперировать в дальнейшем ими, а не конкретными реализациями. Создадим два интерфейса MailSender и OrderRepository, которые и станут нашими абстракциями и мплементируем данные интерфейсы в уже готовых для этого классах:

interface MailSender {
    void sendConfirmationEmail(Order order);
}

interface OrderRepository {
    boolean save(Order order);
}

public class ConfirmationEmailSender implements MailSender {
    @Override
    public void sendConfirmationEmail(Order order) {
        String name = order.getCustomerName();
        String email = order.getCustomerEmail();
        // Шлем письмо клиенту
    }
}

public class MySQLOrderRepository implements OrderRepository {
    @Override
    public boolean save(Order order) {
        MySqlConnection connection = new MySqlConnection("database.url");
        // сохраняем заказ в базу данных
        return true;
    }
}
Теперь наш класс OrderProcessor зависит от абстракций, а не от конкретных реализаций.
Внесем в него изменения, внедряя наши зависимости в конструкторе класса:

public class OrderProcessor {

    private MailSender mailSender;
    private OrderRepository repository;

    public OrderProcessor(MailSender mailSender, OrderRepository repository) {
        this.mailSender = mailSender;
        this.repository = repository;
    }

    public void process(Order order){
        if (order.isValid() && repository.save(order)) {
            mailSender.sendConfirmationEmail(order);
        }
    }
}
Поведение класса теперь можно без труда менять, внедряя нужную зависимость в момент создания экземпляра OrderProcessor.

Еще примеры

к оглавлению

20. Последствия нарушения DIP?
Каждое изменение абстрактного интерфейса вызывает изменение его конкретной реализации. Изменение конкретной реализации, напротив, не всегда сопровождается изменениями и даже обычно не требует изменений в соответствующих интерфейсах. Т.е. интерфейсы менее изменчивы, чем реализации.

Вместо замены реализации, придется изменять сам класс.

Если в приложении абстракции не отделены от деталей, то изменение логики в низкоуровневых реализациях может неожидано привести к поломке высокоуровневых модулей. Тестировать такую систему будет очень сложно. Даже если получится написать модульные тесты, то любое изменение в системе приведет к тому, что эти тесты придется переписывать.

В результате получим жесткую, хрупкую, неподвижную систему, которую сложно тестировать.

Жесткость - тяжело менять систему, потому что каждое изменение затрагивает очень много различных ее частей.

Хрупкость - когда вы вносите изменения в одну часть системы, то в неожиданном месте ломается другая.

Неподвижность - очень сложно повторно использовать код в другом приложении, т.к. модули сильно связаны между собой.

к оглавлению

21. Расскажите что такое автоматическое тестирование?
Автоматическое тестирование – проверка ПО выполняется с помощью специальных инструментов. Оценка результатов проводится автоматически.

Основные шаги теста (запуск, инициализация, выполнение, анализ и выдача результата) проводятся автоматически посредством программных средств.

сокращает время тестирования и упрощает его процесс.
повышает качество тестирования (исключается человеческий фактор),
обеспечивает повторное использование тестов при корректировке ПО, что особенно важно в больших проектах.
к оглавлению

22. Как в Java осуществляется автоматическое тестирование?
С помощью библиотек для автоматического тестирования (например):

Selenium - набор различных программных инструментов, каждый из которых имеет свой подход к поддержке автоматизации тестирования веб-приложений на многих платформах.

JUnit - фреймворк для написания повторяющихся тестов. Это экземпляр архитектуры xUnit для платформ модульного тестирования.

к оглавлению

23. Что такое JUnit и как используется для тестирования?
JUnit — это фреймворк автоматического тестирования отдельных модулей кода, например, методов или классов. Тест это отдельный класс.

Юнит-тесты должны быть небольшими. В идеальном случае — одно утверждение (assert) на тест. Так модульнй тест будет соответствовать SRP, а также быстрее выполняться.

В юнит-тестах стоит использовать шаблон "Arrange, Act and Assert (AAA)", т.е. четко определить:

Arrange - предусловия (инициализация тестовых данных, предварительные установки);
Act - действие (вызыв тестируемого метода);
Assert - постусловия (что должно быть в результате выполнения действия).
Подобное оформление повышает читаемость кода и облегчает его использование в качестве документации к тестируемой функциональности.

import org.junit.Assert;
import org.junit.Test;

import static org.hamcrest.core.Is.is;

public class TemplateTest {

    @Test
    public void whenUniqueKeysThenTheyAreReplaced() {
       
        //arrange
        Template template = new SimpleGenerator();
        String data = "I am ${name}, Who are ${subject}?";
        Map<String, String> map = new HashMap<>();
        map.put("name", "Petr");
        map.put("subject", "you");
        String expected = "I am Petr, Who are you?";

        //act
        String result = template.generate(data, map);

        //action
        Assert.assertThat(result, is(expected));
    }
}
Для улучшения читаемости кода в связке c JUnit используется библиотека matcher-ов Hamcrest. Matcher – это выражение, тестирующее на совпадение с определенным условием.

Плюсы использования JUnit:

Открытый исходный код, тестовые наборы/комплекты, аннотации, простая интеграция (Spring, CI и т.д.)
При рефакторинге кода, тесты JUnit помогут нам проследить, чтобы логика нашей программы не поломалась.
JUnit сработает еще лучше в связке с Maven. При сборке проекта Maven обязательно проведет все тесты и потом соберет готовый проект. Если тесты будут провалены, проект не будет собран, но мы будем знать причины, и так будет легче разобраться где именно поломка.
обзор JUnit

к оглавлению

24. Что такое функциональное тестирование и чем отличается от модульного?
Обычно используют два вида автоматических тестов:

Модульное тестирование (unit testing) — это тестирование отдельных отдельных частей продукта. Unit — наименьшая тестируемая часть ПО, обычно метод или класс.

Юнит-тесты проверяют выполнение конкретного набора задач методом или классом. Юнит тестирование по определению является тестированием белого ящика.

Функциональное тестирование (functional testing) — это тестирование некоего функционала продукта, при этом продукт воспринимается как единый «чёрный ящик».

Функциональные тесты проверяют работу системы на соответствие требованиям, указанным в спецификации продукта. Внешнее поведение системы (логика работы продукта) проверяется независимо от внутренней реализации.

Отличия:

Даже успешное прохождение всех юнит-тестов не гарантирует правильной работы продукта: ведь одна и та же функция может быть использована в различных частях системы, в то время как юнит-тест писался для неё с оглядкой лишь на один вариант использования.

Функциональные тесты полностью определяют (по крайней мере должны) работоспособность продукта. И прежде всего нужны заказчику/руководителю разработки. Юнит-тестирование прежде всего нужно самим разработчикам, для быстрого нахождения ошибок или проверки последствий рефакторинга.

к оглавлению

25. Расскажите про принцип TDD?
Разработка через тестирование (test-driven development, TDD) — техника разработки ПО, основанная на повторении коротких циклов разработки:

пишется тест, покрывающий желаемое изменение;
пишется код, который позволит пройти тест;
проводится рефакторинг нового кода к соответствующим стандартам.
Следуя TDD, вы получаете следующие преимущества:

ваш код полностью покрыт тестами;
создавая тесты до написания кода класса, вы заранее задумаетесь об его использовании, что положительно скажется как на качестве внешнего интерфейса класса, так и на архитектуре проекта в целом;
хорошие тесты могут легко заменить документацию, т.к. наглядно демонстрируют использование трестируемого кода.
к оглавлению

26. Расскажите про принцип BDD?
Разработка на основе поведения (behavior-driven development, BDD) - это методология разработки ПО, являющаяся ответвлением от методологии разработки через тестирование (TDD), при которой особое внимание уделяется описанию поведения системы/модуля в терминах бизнеса(заказчика).

Основная идея - совмещение в процессе разработки чисто технических интересов и интересов бизнеса. Для общения между этими группами на естественном языке, понятном неспециалисту, формулируется поведение программного продукта и ожидаемые результаты.

BDD фокусируется на следующих вопросах:

С чего начинается процесс?
Что нужно тестировать, а что нет?
Сколько проверок должно быть совершено за один раз?
Что можно назвать проверкой?
Как понять, почему тест не прошёл? Исходя из этих вопросов, BDD требует, чтобы имена тестов были целыми предложениями, которые начинаются с глагола в сослагательном наклонении и следовали бизнес целям. Описание приемочных тестов должно вестись на гибком языке пользовательской истории, например,
Как [роль того, чьи бизнес интересы удовлетворяются] я хочу, 
чтобы [описание функциональности так, как она должна работать], 
для того чтобы [описание выгоды].
Критерии приёмки должны быть описаны через сценарий, который реализует пользователь, чтобы достигнуть результата.

Резюме

TDD — делать вещи правильно. BDD — делать правильные вещи. Они не взаимозаменяемы.

TDD проверяет исключительно модули, а BDD — пользовательские сценарии.

TDD используется для разработки через модульное тестирование непосредственно программистами, которые пишут код через этот подход.
 BDD в основном используется для проверки взаимодействия разных компонентов системы, это уровень интеграционного тестирования —
 оно поведенческое и проверяет различные бизнес-кейсы.

TDD — это больше о программировании и тестировании на уровне технической реализации продукта, когда тесты создают сами разработчики. BDD предполагает описание тестировщиком или аналитиком пользовательских сценариев на естественном языке — если можно так выразиться, на языке бизнеса.

к оглавлению

27. Что такое тестирование черным ящиком?
тестирование "черного ящика" – это:

тестирование, как функциональное, так и нефункциональное, не предполагающее знания внутреннего устройства компонента или системы.
тест-дизайн, основанный на технике черного ящика – процедура написания или выбора тест-кейсов на основе анализа функциональной или нефункциональной спецификации компонента или системы без знания ее внутреннего устройства.
Тестируемая программа для тестировщика – как черный непрозрачный ящик, содержания которого он не видит. Целью этой техники является поиск ошибок в таких категориях как:

неправильно реализованные или недостающие функции;
ошибки интерфейса;
ошибки в структурах данных или организации доступа к внешним базам данных;
ошибки поведения или недостаточная производительности системы;
Таким образом, мы не имеем представления о структуре и внутреннем устройстве системы. Нужно концентрироваться на том, что программа делает, а не на том, как она это делает.

к оглавлению

Тестирование
Тестирование программного обеспечение можно разделить на два вида:

тестирование черного ящика;
тестирование белого ящика.
Во время тестирования программы как черного ящика внутренняя структура приложения в расчет не принимается. Все, что имеет значение, это функциональность, которую приложение должно обеспечить. При тестировании программы как белого ящика во внимание принимается внутренняя структура, т.е. класс и методы.

Кроме этого, тестирование можно разделить на четыре уровня:

Unit-тестирование — проверяет корректность работы отдельных модулей программы в изоляции.
Интеграционное — проверка корректности взаимодействия и совместной работы группы модулей друг с другом.
Системное — тесты проверяют работоспособность системы целиком.
Приёмочное — итоговое тестирование готовой системы на соответствие требованиям. В реальном окружении, с реальными данными, на реальных сценариях.
Юнит-тестирование по определению является тестированием белого ящика.

Тестирование "черного ящика" — методология при которой тестер не имеет доступа к исходному коду (UI\UX тестирование, тестирование установки, тестирование локализации)

Тестирование "белого ящика" — методология при которой тестер(чаще сам разработчик или тестер-автоматизатор) имеет доступ к исходному коду продукта(Unit тестирование). Как правило, в данном случае баг репорт отражает именно ошибки в коде, а не в функциональном поведении.

Тестирование "серого ящика" — это расширенная методология “черного”, но при этом тестер также не имеет доступ к исходному коду(или имеет совсем ограниченный), но представляет как система устроена логически, может поделить её на модули и искать в них ошибки используя специальные методики(например, взаимодействие веб-приложений по сети).

Источники:
SOLID

"Чистая архитектура" Р.Мартин 2018

https://academy.realm.io/posts/donn-felker-solid-part-1/

https://habr.com/ru/post/348286/

https://slide-share.ru/principi-solid-256783

https://blog.byndyu.ru/2009/10/solid.html

https://ru.wikipedia.org/wiki/SOLID_(%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)

https://habr.com/ru/post/208442/

JavaDoc

https://www.oracle.com/technetwork/java/codeconventions-150003.pdf

Testing

Автоматизированное тестирование

https://ru.wikipedia.org/wiki/%D0%90%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D0%B7%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5

обзор JUnit

http://java-online.ru/blog-junit.xhtml

https://ru.wikipedia.org/wiki/JUnit

обзор Selenium

https://www.seleniumhq.org/docs/01_introducing_selenium.jsp

Arrange Act Assert

http://wiki.c2.com/?ArrangeActAssert

https://habr.com/ru/post/191986/

https://medium.com/pjbgf/title-testing-code-ocd-and-the-aaa-pattern-df453975ab80

TDD vs BDD

https://habr.com/ru/company/jugru/blog/329468

http://blog.bausov.pro/tdd-bdd-tests/

https://toster.ru/q/302924

https://dou.ua/forums/topic/8897/